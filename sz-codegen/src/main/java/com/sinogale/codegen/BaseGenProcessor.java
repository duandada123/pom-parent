package com.sinogale.codegen;

import com.google.common.collect.Sets;
import com.sinogale.common.annotation.FieldDesc;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementFilter;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.io.File;
import java.io.IOException;
import java.lang.annotation.Annotation;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public abstract class BaseGenProcessor<T extends Annotation> extends AbstractProcessor
{
    protected final Class processAnnotation;
    protected Filer filer;
    protected Messager messager;
    protected Types types;
    protected Elements elements;

    public BaseGenProcessor(final Class<T> tClass) {
        this.processAnnotation = tClass;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Sets.newHashSet(new String[] { this.processAnnotation.getCanonicalName() });
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @Override
    public synchronized void init(final ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        this.filer = processingEnv.getFiler();
        this.types = processingEnv.getTypeUtils();
        this.elements = processingEnv.getElementUtils();
        this.messager = processingEnv.getMessager();
    }

    @Override
    public boolean process(final Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
        final Set<Element> annotatedClass = (Set<Element>)roundEnv.getElementsAnnotatedWith(this.processAnnotation);
        for (final TypeElement e : ElementFilter.typesIn(annotatedClass)) {
            this.genCode(e, roundEnv);
        }
        return false;
    }

    public Set<VariableElement> filterFields(final List<? extends Element> elements, final Predicate<Element> predicate) {
        final Set<VariableElement> variableElements = ElementFilter.fieldsIn(elements).stream().filter(predicate).collect(Collectors.toSet());
        return variableElements;
    }

    public void genJavaFile(final String packageName, final String pathStr, final TypeSpec.Builder typeSpecBuilder, final boolean override) {
        final JavaFile javaFile = JavaFile.builder(packageName, typeSpecBuilder.build()).addFileComment("---Auto Generated by codegen ---", new Object[0]).build();
        try {
            final Path path = Paths.get(pathStr, new String[0]);
            final File file = new File(path.toFile().getAbsolutePath());
            javaFile.writeTo(file);
        }
        catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    public void genJavaFileToTarget(final String packageName, final TypeSpec.Builder typeSpecBuilder) {
        final JavaFile javaFile = JavaFile.builder(packageName, typeSpecBuilder.build()).build();
        try {
            javaFile.writeTo(this.filer);
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

    protected String getFieldDesc(final VariableElement ve) {
        return Optional.ofNullable(ve.getAnnotation(FieldDesc.class)).map(s -> s.name()).orElse(ve.getSimpleName().toString());
    }

    public TypeElement getSuperClass(final TypeElement element) {
        final TypeMirror parent = element.getSuperclass();
        if (parent instanceof DeclaredType) {
            final Element elt = ((DeclaredType)parent).asElement();
            if (elt instanceof TypeElement) {
                return (TypeElement)elt;
            }
        }
        return null;
    }

    protected abstract void genCode(final TypeElement p0, final RoundEnvironment p1);
}
